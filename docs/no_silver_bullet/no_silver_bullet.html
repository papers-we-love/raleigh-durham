
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <title>No Silver Bullet Â· GitBook</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="GitBook 3.2.2">
        
        
        
    
    <link rel="stylesheet" href="../../gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../../gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="../../gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="../database_metatheory/database_metatheory.html" />
    
    
    <link rel="prev" href="../quickcheck/quickcheck.html" />
    

    </head>
    <body>
        
<div class="book">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Type to search" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="../../">
            
                <a href="../../">
            
                    
                    Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" data-path="../api_design/api-design-notes.html">
            
                <a href="../api_design/api-design-notes.html">
            
                    
                    API Design
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3" data-path="../quickcheck/quickcheck.html">
            
                <a href="../quickcheck/quickcheck.html">
            
                    
                    QuickCheck
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="1.4" data-path="no_silver_bullet.html">
            
                <a href="no_silver_bullet.html">
            
                    
                    No Silver Bullet
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5" data-path="../database_metatheory/database_metatheory.html">
            
                <a href="../database_metatheory/database_metatheory.html">
            
                    
                    Database Metatheory
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6" data-path="../reflections_on_trusting_trust/reflectionsOnTrustingTrust.html">
            
                <a href="../reflections_on_trusting_trust/reflectionsOnTrustingTrust.html">
            
                    
                    Reflections on Trusting Trust
            
                </a>
            

            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            Published with GitBook
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href="../.." >No Silver Bullet</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <h1 id="no-silver-bullet-essence-and-accident-in-software-engineering">No Silver Bullet Essence and Accident in Software Engineering</h1>
<h1 id="table-of-contents">Table of Contents</h1>
<ol>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#does-it-have-to-be-hard">Does It Have To Be Hard</a><ol>
<li><a href="#complexity">Complexity</a></li>
<li><a href="#conformity">Conformity</a></li>
<li><a href="#changeability">Changeability</a></li>
<li><a href="#invisibility">Invisibility</a></li>
</ol>
</li>
<li><a href="#past-breakthroughs-solved-accidental-difficulties">Past Breakthroughs Solved Accidental Difficulties</a><ol>
<li><a href="#high%5C-level-languages">High-level languages</a></li>
<li><a href="#time%5C-sharing">Time-sharing</a></li>
<li><a href="#unified-programming-environments">Unified programming environments</a></li>
</ol>
</li>
<li><a href="#hopes-for-the-silver">Hopes for the Silver</a><ol>
<li><a href="#ada-and-other-high%5C-level-language-advances">Ada and other high-level language advances</a></li>
<li><a href="#object%5C-oriented-programming">Object-oriented programming</a></li>
<li><a href="#artificial-intelligence">Artificial intelligence</a></li>
<li><a href="#expert-systems">Expert systems</a></li>
<li><a href="#automatic-programming">Automatic programming</a></li>
<li><a href="#graphical-programming">Graphical Programming</a></li>
<li><a href="#program-verification">Program verification</a></li>
<li><a href="#environments-and-tools">Environments and tools</a></li>
<li><a href="#workstations">Workstations</a></li>
</ol>
</li>
<li><a href="#promising-attacks-on-the-conceptual-essence">Promising Attacks on the Conceptual Essence</a><ol>
<li><a href="#buy-versus-build">Buy versus build</a></li>
<li><a href="#requirements-refinement-and-rapid-prototyping">Requirements refinement and rapid prototyping</a></li>
<li><a href="#incremental-development-grow-not-build-software">Incremental development grow not build software</a></li>
<li><a href="#great-designers">Great designers</a></li>
</ol>
</li>
</ol>
<h2 id="introduction">Introduction</h2>
<blockquote>
<p>There is no single development, in either technology or management technique, which by itself promises even one  order of magnitude improvement in productivity, in reliability, in simplicity.</p>
</blockquote>
<ul>
<li>Innovations in the software can yield an &quot;order-of-magnitude&quot; improvement</li>
<li>Example given in medicine where doctors where taught the benefits of cleanliness improving health of patients<ul>
<li>In the same way improving processes in software can help improve software step by step</li>
</ul>
</li>
</ul>
<h2 id="does-it-have-to-be-hard">Does It Have To Be Hard</h2>
<ul>
<li><p>Software can&apos;t hope to see the gains that hardware has seen with improved chip design every 2 years.</p>
</li>
<li><p>Software construction really can&apos;t be compared with hardware constructions.</p>
<ol>
<li>Hardware advances in the last 30 years cannot be compared to any other technology</li>
</ol>
</li>
<li><p>Difficulties in Software:</p>
<blockquote>
<p>I believe the hard part of building software to be the specification, design, and testing of this conceptual construct, not the labor of representing it and testing the fidelity of the representation.</p>
</blockquote>
<ol>
<li>Syntax errors in software pale in comparison to conceptual errors in a system</li>
<li>There is no silver bullet</li>
</ol>
</li>
</ul>
<h4 id="complexity">Complexity</h4>
<ul>
<li>Computers themselves are among the most complicated things humans build</li>
<li>Software Construction is more than merely putting parts together<ul>
<li>Elements of a software system interact in nonlinear ways</li>
</ul>
</li>
<li>Example given in mathematics where advances in math came for 3 straight centuries because of simplified models</li>
<li>Complexities in Software Construction create the following issues:<ul>
<li>Communication among team members<ul>
<li>In turn produces product flaws, cost overruns, schedule delays</li>
</ul>
</li>
<li>Complexity in understanding all possible states of a system and enumerating the states of a system<ul>
<li>This drives unreliability</li>
</ul>
</li>
<li>Complexity thereby make programs hard to use</li>
<li>Complexity makes programs harder to extend newer functionality and consequently introducing side effects</li>
<li>Complexity also makes security of a software system more difficult to understand</li>
<li>Complexity also makes management more difficult</li>
</ul>
</li>
</ul>
<h4 id="conformity">Conformity</h4>
<ul>
<li>Software engineers face added complexity because they must conform to decisions made by others</li>
<li>Conforming to other software components itself makes software systems more complex</li>
</ul>
<h4 id="changeability">Changeability</h4>
<ul>
<li>Since software is much more malleable and easier to change this by itself introduces more challenges</li>
<li>Users of a software system find new uses for software and thereby introduce new complexities</li>
<li>A combination of users of a software system, laws introduced, and new software machinery add difficulties as well</li>
</ul>
<h4 id="invisibility">Invisibility</h4>
<ul>
<li>Software is inherently invisible and hard to visualize if even possible</li>
<li>Attempts to visualize a system become difficult because of all the working pieces</li>
<li>Since software cannot be easily visualized this in turn adds more complexity to systems</li>
</ul>
<h2 id="past-breakthroughs-solved-accidental-difficulties">Past Breakthroughs Solved Accidental Difficulties</h2>
<p>The 3 Steps in software that have helped accidental difficulties:</p>
<ol>
<li>High-level Languages</li>
<li>Time-sharing</li>
<li>Unified programming environments</li>
</ol>
<h4 id="high-level-languages">High-level languages</h4>
<p>High-level languages helps in the following ways:</p>
<ul>
<li>Alleviates accidental complexity</li>
<li>Diminish complexities that arose from programming in assembly language and understanding machine code</li>
<li>Improve processes by the use of higher level concepts such as data structures and data types</li>
</ul>
<h4 id="time-sharing">Time-sharing</h4>
<ul>
<li>Reduced compilation and execution times of software systems help keep program logic in context<ul>
<li>This is true because a shorter feedback loop helps engineers keep focused on the task at hand</li>
</ul>
</li>
</ul>
<h4 id="unified-programming-environments">Unified programming environments</h4>
<ul>
<li>Development of Unix and Interlisp helped with using software programs together and improving productivity</li>
<li>Unified file formats, and integrated libraries helped immeasurably as well</li>
</ul>
<h2 id="hopes-for-the-silver">Hopes for the Silver</h2>
<p><strong>Looking at possible silve bullets</strong></p>
<h4 id="ada-and-other-high-level-language-advances">Ada and other high-level language advances</h4>
<ul>
<li>Ada is touted as a very influential programming language</li>
<li>Ada&apos;s philosophy more than its features as a language have been influential</li>
<li>Fred Brooks makes a prediction that Ada will have an impact by training engineers with modern software practices</li>
</ul>
<h3 id="object-oriented-programming">Object-oriented programming</h3>
<ul>
<li>Argues that object-oriented programming (OOP) helps remove boilerplate of previous software constructs</li>
<li>OOP helps with higher-order design of software systems</li>
<li>Argues that OOP can only help if some of the troubles of <code>type specification</code> is reduced in systems</li>
</ul>
<h4 id="artificial-intelligence">Artificial intelligence</h4>
<p>Brooks examines argument made by <code>Parnas</code> on AI</p>
<ol>
<li>The use of computers to solve problems that previously could only be solved by applying human intelligence.<ol>
<li>Argument is made that what people consider is AI today can rapidly change, kind of like a floating goal.</li>
</ol>
</li>
<li>The use of a specific set of programming techniques knows as heuristic or rule-based programming.<ol>
<li>Not detail expounded on rule based systems but I can surmise that there are unspoken challenges since this requires expert knowledge that must be gleaned from an actual expert</li>
</ol>
</li>
</ol>
<h4 id="expert-systems">Expert systems</h4>
<ul>
<li>Inference engines offer advantages over deterministic logic through application independence and varied use</li>
<li>Rule sets can encode universal ideas that can be applied to different applications thereby distributing complexity</li>
<li>Argues that separation of application complexity from the software program itself is an important advance</li>
</ul>
<p>Applications for software tasks:</p>
<ul>
<li>Suggest interface rules</li>
<li>Help with testing strategies</li>
<li>Optimization strategies</li>
<li>Argues that rule-based systems should become more hierarchically modularized in the same that a system does</li>
<li>Argues that test case generation is work that has to be done anyways and rules can help maintenance of a system</li>
</ul>
<p>Difficulties in Expert Systems:</p>
<ol>
<li>Difficult going from program structure specification to the semi-automatic generation of diagnostic rules</li>
<li><p>Knowledge Acquisation is difficult for several reasons:</p>
<ol>
<li>Finding experts that are articulate enough and understand why they do things.</li>
<li>Extracting information from experts in order to distill into the rule bases is another</li>
<li>Experts are required</li>
</ol>
</li>
<li><p>Distilling knowledge to inexperienced programmers from the best programmers is also no simple task.</p>
</li>
<li>A tool that disseminates this knowledge is extremely important</li>
</ol>
<h4 id="automatic-programming">Automatic programming</h4>
<blockquote>
<p>In short, automatic programming always has been a euphemism for programming with a higher-level language than was presently available to the programmer.</p>
</blockquote>
<p>Automatic Programming favorable qualities:</p>
<ul>
<li>The problems are readily characterized by relatively few parameters.</li>
<li>There are many known methods of solution to provide a library of alternatives.</li>
<li>Extensive analysis has led to explicit rules for selecting solution techniques, given problem parameters</li>
</ul>
<p><strong>Argues that such programming seems difficult to even achieve</strong></p>
<h4 id="graphical-programming">Graphical Programming</h4>
<ul>
<li>Argues that uses of flow-chart is a poor abstraction of software construction</li>
<li>Argues that it is a useless design tool used by programmers since it is used after writing programs not before</li>
<li>Argues that desktop computer sophistication is a hindrance to software systems underlying complexity<ul>
<li>As this was written in 1986 many advances have occurred with software so not sure about this point</li>
</ul>
</li>
<li>Argues that software is very difficult to visualize<ul>
<li>The following graphical tools:<ul>
<li>Diagram control flow, varible scope nesting, variable cross-references, data flow, hierarchical data structures</li>
<li>Even with these tools it is difficult to get a global overview of a software system.</li>
</ul>
</li>
</ul>
</li>
<li>A software systems cannot be visualized in the same way that hardware systems can</li>
</ul>
<h4 id="program-verification">Program verification</h4>
<ul>
<li>Argues that Program verification is powerful but labor intensive and very few programs have been proven correct</li>
<li>Argues that program verification can only assert that a program meets its specification</li>
</ul>
<blockquote>
<p>The hardest part of the software task is arriving at a complete and consistent specification, and much of the essence of building a program is in fact the debugging of the specification.</p>
</blockquote>
<h4 id="environments-and-tools">Environments and tools</h4>
<ul>
<li>Smart Editors at most can help with syntactic errors and simple semantic errors</li>
<li>&quot;Integrated Database Systems&quot; that keep track of details that programmer&apos;s must understand<ul>
<li>I am assuming here that &quot;Object Relational Mappers&quot; could be considered nice tools to extract business logic</li>
<li>Examples like linq instead of using Stored Procedures and Table Triggers</li>
</ul>
</li>
</ul>
<h4 id="workstations">Workstations</h4>
<ul>
<li>The point is made that even with factor of 10 speed increases in developer workstations you still have think time<ul>
<li>Think time being the time a developer uses modelling out business logic and program flow I assume</li>
</ul>
</li>
</ul>
<h2 id="promising-attacks-on-the-conceptual-essence">Promising Attacks on the Conceptual Essence</h2>
<p>Productivity Equation:</p>
<p><script type="math/tex; "> \sum(Frequency)_i x (Time)_i </script></p>
<p>Focusing on the task at hand or the conceptual essence is not the silver bullet as well</p>
<h4 id="buy-versus-build">Buy versus build</h4>
<ul>
<li>It is cheaper to buy production ready software than try to write homegrown software<ul>
<li>Argues that a software system costing $100,000 could be roughly equivalent to a yearly salary of a developer</li>
</ul>
</li>
<li>Argument made that the ratio of hardware/software cost has changed dramatically<ul>
<li>if you spent 2 million on a piece of hardware then spending another $250,000 on software is a drop in the bucket</li>
</ul>
</li>
<li>Development of spreadsheet and office technologies has enabled the mainline computer user to find new uses<ul>
<li>Argues such office software has the possibility of being a force multiplier in advances through novel uses</li>
</ul>
</li>
</ul>
<h4 id="requirements-refinement-and-rapid-prototyping">Requirements refinement and rapid prototyping</h4>
<ul>
<li>Clients find it hard to nail down the exact requirements that they want</li>
<li>Will often take multiple versions of a prototype to nail down what the client wants</li>
<li>Points out that rapid prototype tools can assist greatly in solving software problems</li>
</ul>
<blockquote>
<p>The  purpose  of  the  prototype  is  to  make  real  the  conceptual  structure  specified,  so  that  the  client  can  test  it  for  consistency  and  usability</p>
</blockquote>
<p><strong>Iterative development and the use of prototypes is key to building satisfactory software system</strong></p>
<h4 id="incremental-development-grow-not-build-software">Incremental development grow not build software</h4>
<ul>
<li>Calls for iterative development in software<ul>
<li>Flesh out details bit by bit in a system</li>
<li>I would argue that TDD can help with such things by facilitating with incremental design</li>
</ul>
</li>
</ul>
<blockquote>
<p>That is, the system should first be made to run, even though it does nothing useful except call the proper set of dummy subprograms.  Then, bit-by-bit it is fleshed out, with the subprograms in turn being developed into actions or calls to empty stubs in the level below</p>
</blockquote>
<ul>
<li>The main point is see in this section is that having a running system at all times keeps you focused and attentive</li>
</ul>
<h4 id="great-designers">Great designers</h4>
<ul>
<li>Good design can help drive quality of a system<ul>
<li>Organizations like the Software Engineering Institute help promote good software systems</li>
</ul>
</li>
<li>Argues that great design minds (meaning individuals) can accomplish more than a committee of designers</li>
<li>Find ways to nurture highly creative minds as they can pave the way to the future<ul>
<li>Examples are given with Unix, SmallTalk, Fortran and others that were largely individual efforts</li>
</ul>
</li>
<li>Argues that organizations must cultivate great designers just like they would with management prospects</li>
</ul>
<p>Highlights the following ways to grow great designers:</p>
<ul>
<li>Systematically identify top designers as early as possible. The best are often not the most experienced</li>
<li>Assign a career mentor to be responsible for the development of the prospect, and keep a careful career file</li>
<li>Devise and maintain a career development plan for each prospect</li>
<li>including carefully selected apprenticeships with top designers, episodes of advanced formal education</li>
<li>short courses, all interspersed with solo design and technical leadership assignments</li>
<li>Provide opportunities for growing designers to interact with and stimulate each other</li>
</ul>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="../quickcheck/quickcheck.html" class="navigation navigation-prev " aria-label="Previous page: QuickCheck">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="../database_metatheory/database_metatheory.html" class="navigation navigation-next " aria-label="Next page: Database Metatheory">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"No Silver Bullet","level":"1.4","depth":1,"next":{"title":"Database Metatheory","level":"1.5","depth":1,"path":"docs/database_metatheory/database_metatheory.md","ref":"docs/database_metatheory/database_metatheory.md","articles":[]},"previous":{"title":"QuickCheck","level":"1.3","depth":1,"path":"docs/quickcheck/quickcheck.md","ref":"docs/quickcheck/quickcheck.md","articles":[]},"dir":"ltr"},"config":{"gitbook":"*","theme":"default","variables":{},"plugins":["mathjax"],"pluginsConfig":{"mathjax":{"forceSVG":false,"version":"2.6-latest"},"highlight":{},"search":{},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"sharing":{"facebook":true,"twitter":true,"google":false,"weibo":false,"instapaper":false,"vk":false,"all":["facebook","google","twitter","weibo","instapaper"]},"fontsettings":{"theme":"white","family":"sans","size":2},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56}},"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"}},"file":{"path":"docs/no_silver_bullet/no_silver_bullet.md","mtime":"2017-04-11T01:42:42.000Z","type":"markdown"},"gitbook":{"version":"3.2.2","time":"2017-06-01T19:03:25.487Z"},"basePath":"../..","book":{"language":""}});
        });
    </script>
</div>

        
    <script src="../../gitbook/gitbook.js"></script>
    <script src="../../gitbook/theme.js"></script>
    
        
        <script src="https://cdn.mathjax.org/mathjax/2.6-latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-mathjax/plugin.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-sharing/buttons.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

